1. application.yml에서 비밀번호는 string으로 줘야함


2. core에는 application.yml 필요 없다.
core는 라이브러리 역할을 하는 것이고, 이 말은 즉슨
실제로 SpringbootApplication이 있는 것이 아라는 것이다.

그래서, yml 파일은 필요없게 된다.

결론 : SpringbootApplication이 존재하는 모듈마다(모듈에만), yml 파일 만들어야 한다


3. gradle로 프로젝트 생성 방법
-> 그냥 new module에서 gradle 선택


4. 특정 필드 제외한 생성자(빌더)로 객체 생성 시, 나머지 필드에는 어떤 값이 들어가는지
- null로 들어간다
- (즉, 필드 자체에 값이 없는 것이 아니다. null이라는 값이 들어간다.
따라서 mysql default를 통해 createdAt, updateAt을 지정하려고 하면 안된다.
default는 아예 필드에 값이 없을 경우 활성화되기 때문이다.)



5. 406에러 - getter의 부재
- jackson은 기본생성자, getter 이용해서 직렬화/역직렬화
- response에 getter 붙이지 않아서 생긴 오류

[예외 처리]
<기본용어>
- Throws는 메소드에서 잠재적으로 어떤 Exception이 발생할 수 있는지 명시하는 키워드입니다.
- 예외는 메소드 내에서 try-catch로 처리하는 것이 기본이다. 경우에 따라 throws를 사용하면 메소드를 호출한 곳으로 예외를 떠넘길 경우에 사용하는 것이다.
- (그래서, throws 키워드가 붙은 메소드를 사용할 땐, try-catch로 묶어 try 블록 내에서 호출되어야 한다)

- 이미 throw 한 것을 또 throw하는건 좋은 습관이 아니다!

1. 요청 시 발생하는 에러 2가지
1-1. HttpMessageNotReadableException
    - http body -> 컨트롤러에 들어오는 객체 역직렬화에서 에러
    - 올바르지 않은 JSON 데이터 형태가 들어와서 그런 것

1-2. MethodArgumentNotValidException
    - validation check 실패 시 발생
    - bindingResult 객체에 에러 내용 담김
        - bindingResult에서 defaultMessage, rejectedValue 꺼내서 사용하기

[ResponseEntity vs 일반 객체 리턴]
ResponseEntity
- HTTP header와 body 둘 다 정의할 수 있는 객체

일반 객체
- HTTP body에 내용 담는 것

[custom validation]
1. custom validator 만들기
- 필드 하나에 적용하는 어노테이션
- 필드 여러개의 값을 가져와 검증할 수 있는 어노테이션
    - 클래스 위에 어노테이션 붙인다

2. custom validator 만들기


[field error vs global error]
field error
- 필드 검증 실패 시
- hasGlobalError() -> null
- hasFieldError() -> 값 존재

global error
- 필드 검증이 아닌, 복합적인 validation 실패 시
- hasGlobalError() -> 값 존재
- hasFieldError() -> null


여러개의 field error랑 global error 겹쳐있으면 어떻게..?


[static method]
- static??


[멀티모듈로 만든 이유]
model <- api 로 단방향 의존성을 가진다.
즉 api는 model을 의존하지만, model은 api를 의존하지 않는 관계이다.

즉, model은 api의 코드를 가지고 있지 않고, 독립적으로 존재할 수 있다는 뜻이다.
이로써, api 부분을 통째로 바꿔치기 하더라도 model을 그대로 재사용할 수 있는 코드를 만들 수 있는 것이다.

항상, 의존성은 단방향이 좋은 것이다.